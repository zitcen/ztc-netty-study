# 面试题

## 一、spring 

### 1、什么是Spring

​		Spring 是一个java企业级应用开发框架。Spring 框架主要用于 java 应用开发，它的有些拓展针对 J2EE 平台的 WEB 应用开发。Spring 目标是简化 java 企业级应用开发。

​		Spring是一个开源的 java 企业级开发框架。它是一个轻量级的控制反转和面相切面的容器框架。它从大小和消耗两方面来看都是一个轻量级的。它通过控制反转和依赖注入 实现 bean与bean之间的低耦合。

### 2、为什么使用 Spring

​	Spring 有一下优点：

1. Spring是轻量级的，基础版不超过10M
2. 低耦合：通过控制反转实现低耦合
3. 面相切面：通过面向切面编程将系统服务和业务服务分开
4. MVC框架：Spring提供的一个web框架，是WEB框架一个很好的替代品
5. 事务管理：Spring提供一个持续的事务管理接口，可以拓展到下至本地上至全局的的事务
6. 异常处理：Spring提供API将具体的技术异常转换成一致的UNCHECKED 异常

### 3、注解@Resource 与 @Autowired的区别

相同点：它们都可以作用在 Setter 和字段上面，是依赖注入的注解。如果写在字段上面就可以不用写Setter方法了。

不同点：前者默认通过名称装配对象，后者默认通过类型找对象；

### 4、依赖注入有几种方式？

三种方式

1. Setter方法注入，Spring通过调用成员变量的Setter函数将被依赖对象注入给依赖类。它十分灵活，但是在没有
2. 构造函数注入，初始化完成后就可以获得使用的对象。当需要注入的对象很多的时候，构造函数参数列表会很长，不够灵活。
3. 接口注入：依赖类必须要实现指定的接口，然后实现该接口的一个函数，该函数用于依赖注入。入侵性太强，不建议使用。

### 5、讲一讲什么是spring

​	spring是一个轻量级IOC和AOP框架。是为java提供基础性服务的一套框架。目的是用于简化企业应用的开发，让开发只关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。

spring的重要模块有

- springCORE:spring的核心，提供IOC服务
- springContext：提供框架式的bean访问方式，以及企业级功能
- springAop：面相切面编程服务
- springDAO：对JDBC的抽象，简化数据库访问的异常
- springORM：对现有的ORM框架的支持
- springWEB：提供了基本的面相WEB的综合特性，例如多方文件传输。
- springMVC：提供面向web的Controller-model-view的实现

### 6、说说你对SpringMVC的理解

MVC是一种设计模式，M--Model 模型，V--View 视图，C--Controller 控制器，SpringMVC是在Spring的基础上加上，提供了一个WEB应用的MVC 模块 ，SpringMVC就是Spring大模块下的一下小的子模块。



### 7、springMVC的主要注解有哪些

1. @Controller ： 标记一个类为SpringMVC的控制器
2. @ResetController：标记一个类为SpringMVC的控制器，并且请求风格为Rest
3. @RequestMapping：用于映射到控制器方法上的注解，也可以用于类上，用于类上表示所有的请求都会经过类注解的路径上
4. @ResponseBody：注解实现Controller方法返回的对象转换为json对象响应给用户
5. @RequestBody：接受http请求的json对象，json对象将转换成java对象
6. @SessionAttribute：将一个对象存放到Session中

### 8、谈谈你对SpringAOP的理解

​		面相切面编程，能够将那些与业务无关，却为业务模块共同调用的逻辑或者责任(如日志处理、事务处理、权限控制等)封装起来，便于减少系统中的重复代码，降低耦合度，便于以后拓展和维护。

​		SpringAOP 是基于动态代理的，如果需要代理的对象实现了某个接口，那么Spring就会使用 JDK 动态代理去创建一个代理对象；如果没有实现的接口，就会使用 CGlib 动态代理来生成一个代理对象。也可以用使用 AspectJ。SpringAOP也集成了AspectJ这个AOP框架。

### 9、AspectJ 与SpringAOP有什么区别

1. AspectJ 是编译时增强，SpringAop是运行时增强。
2. SpringAOP是基于代理，AspectJ是基于字节码
3. AspectJ更加强大更加完整，但是AOP更加简单。Spring已经集成AspectJ框架了。
4. 如果我们的切面比较少两者差异不大，如果切面很多，最好使用 AspectJ。

### 10、什么是通知，通知有那些类型

​		就是AOP需要触发的代码，可以是在程序执行之前，也可是之后。

​		常见的通知

- 环绕通知
- 前置通知
- 后置通知
- 异常通知

### 11、SpringAOP的横切关注点和关注点的区别

  关注点是使用SpringAOP通知的地方，横切关注点是使用SpringAOP通知(使用的功能)

### 12、说说你对SpringIOC的理解

​		SpringIOC就是控制反转。以前对创建对象的控制权和时机是由要使用的对象自己把控的，现在交由Spring的容器中去了。并由容器根据配置去控制对象的创建和各个对象之间的依赖的管理。这样就打成了对象域对象之间的低耦合























## 二、mysql

### 1、数据库的三大凡事

1. 列不可在分，数据库的最小原子项，
2. 行可以唯一区分，主键约束
3. 表的非主属性不能依赖与其他表的非主属性
4. 三个范式从一到三依次依赖，

### 2、mysql的数据库引擎有那些

​		使用 查询语句  show engines;查看mysql数据库的所有引擎

msyql数据库的主要引擎有：

​		**MYISAM：**全锁表，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占有空间小。对只需要进行insert和select的数据可以用此引擎。

​		**Innodb：**行级锁，提供了具有提交、回滚和崩溃恢复能力的事务安全，支持列自动增长，支持外键，并发能力强，占用空间比MYISAM大，处理效率没有MYISAM好

​		**Memory:**全锁表，数据存储在内存中，速度快，会占用与数据成正比的内存空间，重启数据库后、失效。

​		**MERGE：**是一组MYISAM表的组合

### 3、说一说InnoDB与MyISAM的区别

1. InnoDB是支持事务的，而MYISAM不支持事务。INNODB默认是每一条sql 都会被事务封装，自动提交，这样会影响效率，所以最好手动提交事务
2. INNoDB是支持外键的，而MYISAM不支持外键。包含外键的INNODB表不能转换成MYISAM表
3. INNODB是聚集索引，数据文件和索引文件是一起的，必须要有主键，通过主键索引效率会很高。但是辅助索引需要查询两次，先查询主键，再通过主键查询数据。MYISAM是非聚集索引，数据文件是分开的，索引保存的是数据的指针。主键索引与辅助索引是相互独立的。
4. INNODB不保存具体的行数，SELECT count 的时候需要扫描全表，但是MYISAM一个变量保存了整个行数，速度很快
5. INNODB不支持全文索引，但是MYISAM 支持全文索引，所以MYISAM的查询效率要高于INNODB

### 4、数据库的事务

​		什么事事务：执行多条sql，要么同事成功要么同事失败。

事务的四大特性：原子性、一致性 、隔离性、持久性。

原子性：一起的sql要么同时成功，要么同时失败

一致性：执行sql前后的数据总数不变

隔离性：并发数据操作时，各自的事务有各自事务操作的空间，互相不干扰。

持久性：一旦事务提交成功，事务的所有操作都必须提交到数据库中

##  三、mybatis

### 1、什么是mybatis

​		mybatis 是一个半orm(对象关系映射)框架，它的内部封装了JDBC，开发者只需要关心 SQL本身，不需要处理加载、创建链接、创建statement等操作。开发编写原生sql，可以严格控制sql的执行性能，灵活度高；mybatis可以使用xml或者注释来配置和映射原生信息，将POJO映射成数据库记录，避免了几乎所有的JDBC代码和手动设置参数；通过XML文件或者注释的方法将要执行的各种statement配置起来，并通过java对象和statement中的sql的动态参数进行映射成最终需要执行的sql语句，最后由mybatis框架执行sql语句并将返回结果映射成java对象返回。







### springBean的生命周期



1、创建：先创建bean实例

2、注入属性值：通过反射

3、调用  BeanNameAware 的 setBeanName ：如果改  bean 实现了 BeanNameAware 接口，spring 将会该bean的 beanName传递给 接口的 setBeanName  方法。

4、调用 BeanFactoryAware 的 setBeanFactory ：如果 bean 实现了 BeanFactoryAware 接口，spring 将 beanfactory 的实例传入到 bean中，通过setBeanFactory。
5、调用 ApplicationContextAware 的  setApplicationContext ：如果bean 实现了 ApplicationContextAware ，spring将会调用 setApplicationContext 将 当前的 applicationContext 传递给bean

6、**BeanPostProcessor** 前置处理器： 如果bean 实现了BeanPostProcessor接口在这儿会调用前置处理 postProcessBeforeInitialization 方法会被调用

7、**InitializingBean** 属性初始化后置处理 ：继承了改 接口的bean 需要实现 afterPropertiesSet 方法

8、自定义的 init 方法：如果Bean定义了init方法，该方法将被调用。

9、**BeanPostProcessor** 的后置处理： 如果bean 实现了BeanPostProcessor接口在这儿会调用后置处理 AfterInitialization方法被调用。

10、bean 实例化完成：bean准备就绪，可以被程序使用了

11、调用 DisposableBean 的 destroy ：如果bean 实现了 DisposableBean 接口，当容器关闭的时候 destroy  方法会被调用

12、自定义 destroy  ：如果Bean定义了destroy方法，该方法将被调用。

### spring DI 依赖注入是如何工作的

1、依赖注入(DI)：控制反转(IOC)，由传统的使用者创建对象，到使用者到工厂去拿对象，创建对象的主体由使用者变成了spring容器。

2、通过构造器注入：Spring通过类的构造器参数注入依赖

3、通过 Setter 方法注入： 依赖可以通过 Bean 的Setter 方法传入

4、基于注解的方式传入：使用 @Resource 和@Autowired 直接在属性、构造器和方法上注入依赖

5、XML文件注入：在Spring的XML配置文件中定义Bean及其依赖。

### Spring AOP 的概念

1、AOP 面相切面编程，主要作用在于抽出处理相同事件和发生相同事件的点。

2、切面（Aspect）：横切关注点的模块化，比如日志、安全等。

3、通知（advice）:在切面的某个特定连接点上执行的动作。

4、切点(pointcut):匹配连接点的表达式

5、引入（向现有类添加新方法或者属性）

6、目标对象（Target Object）: 被一个或者多个切面通知的对象

7、织入（Weaving）： 把切面与其他应用类型或者对象连接起来，创建一个被通知的对象

8、连接点（join point） ：程序执行过程中的某个特定点，如方法调用或异常抛出。

### Spring 的事务是如何实现的

1、声明式事务：通过配置XML和注解的方式来配置事务，最常用的方式

2、编程式事务：给与开发者更大的控制权，但是不如声明式事务简洁	

3、事务的隔离级别：脏读、不可重复读、幻读、串行化

5、事务的传播属性：REQUIRED、REQUIRES_NEW等

### SpringMVC 的流程

1、请求到达**DispatcherServlet**：所有请求都需要先到达中央控制器

2、请求映射：DispatcherServlet调用HandlerMapping确定请求的处理器。

3、调用处理器：处理器接收请求并返回ModelAndView对象。

4、视图解析： DispatcherServlet调用ViewResolver来解析Handler返回的视图。

5、返回响应：视图负责渲染并返回给客户端